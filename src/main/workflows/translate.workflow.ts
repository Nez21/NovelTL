import '@langchain/langgraph/zod'

import { StateGraph } from '@langchain/langgraph'
import { z } from 'zod'
import { AccuracyErrorSchema, accuracyEditorNode } from '../nodes/accuracy-editor.node'
import { draftSelectorNode } from '../nodes/draft-selector.node'
import { draftTranslatorNode } from '../nodes/draft-translator.node'
import {
  EditorFeedbackEntrySchema,
  LeadEditorErrorSchema,
  leadEditorNode
} from '../nodes/lead-editor.node'
import { ReadabilityErrorSchema, readabilityEditorNode } from '../nodes/readability-editor.node'
import { refinementNode } from '../nodes/refinement.node'
import { StyleErrorSchema, styleEditorNode } from '../nodes/style-editor.node'
import { CharacterSchema, EditingStatusEnum, LanguageEnum } from '../shared.types'

export const TranslateInputStateSchema = z.object({
  targetLanguage: LanguageEnum,
  styleContext: z.object({
    genre: z.string(),
    authorialStyle: z.string()
  }),
  characterManifest: z.array(CharacterSchema.omit({ characterId: true })),
  glossary: z.array(
    z.object({
      term: z.string(),
      category: z.string(),
      translation: z.string()
    })
  ),
  sourceText: z.string().min(1)
})

export const TranslateOverallStateSchema = TranslateInputStateSchema.extend({
  draftCandidates: z
    .array(z.string())
    .optional()
    .describe('An array of draft translation candidates generated by the draft translator.'),
  translatedText: z
    .string()
    .optional()
    .describe('The translated text segment in the target language.'),
  draftSelectionRationale: z
    .string()
    .optional()
    .describe('The rationale for why a specific draft candidate was selected.'),
  accuracyScore: z
    .number()
    .int()
    .min(0)
    .max(100)
    .optional()
    .describe('The accuracy score assigned by the accuracy editor (0-100).'),
  accuracyFeedback: z
    .array(AccuracyErrorSchema)
    .optional()
    .describe('An array of specific accuracy errors found by the accuracy editor.'),
  styleScore: z
    .number()
    .int()
    .min(0)
    .max(100)
    .optional()
    .describe('The nuance & style score assigned by the style editor (0-100).'),
  styleFeedback: z
    .array(StyleErrorSchema)
    .optional()
    .describe('An array of specific style/nuance errors found by the style editor.'),
  readabilityScore: z
    .number()
    .int()
    .min(0)
    .max(100)
    .optional()
    .describe('The readability score assigned by the readability editor (0-100).'),
  readabilityFeedback: z
    .array(ReadabilityErrorSchema)
    .optional()
    .describe('An array of specific readability/flow errors found by the readability editor.'),
  holisticScore: z
    .number()
    .int()
    .min(0)
    .max(100)
    .optional()
    .describe('The holistic score assigned by the lead editor (0-100).'),
  editorFeedback: z
    .array(LeadEditorErrorSchema)
    .optional()
    .describe('An array of conflicts that were detected and resolved by the lead editor.'),
  finalStatus: EditingStatusEnum.optional(),
  editorFeedbackHistory: z
    .array(EditorFeedbackEntrySchema)
    .optional()
    .describe('A chronological array of all editor feedback entries from the specialized editors.'),
  iterationCount: z
    .number()
    .int()
    .min(0)
    .default(0)
    .describe('The number of translation iterations made so far.')
})

export const TranslateOutputStateSchema = TranslateOverallStateSchema.pick({
  translatedText: true,
  holisticScore: true,
  editorFeedback: true,
  finalStatus: true
})

export type TranslateInputState = z.infer<typeof TranslateInputStateSchema>
export type TranslateOverallState = z.infer<typeof TranslateOverallStateSchema>
export type TranslateOutputState = z.infer<typeof TranslateOutputStateSchema>

const builder = new StateGraph({
  state: TranslateOverallStateSchema,
  input: TranslateInputStateSchema,
  output: TranslateOutputStateSchema
})
  .addNode('draft-translator', draftTranslatorNode)
  .addNode('draft-selector', draftSelectorNode)
  .addNode('accuracy-editor', accuracyEditorNode)
  .addNode('readability-editor', readabilityEditorNode)
  .addNode('style-editor', styleEditorNode)
  .addNode('lead-editor', leadEditorNode)
  .addNode('refinement', refinementNode)
  .addEdge('__start__', 'draft-translator')
  .addEdge('draft-translator', 'draft-selector')
  .addEdge('draft-selector', 'accuracy-editor')
  .addEdge('draft-selector', 'readability-editor')
  .addEdge('draft-selector', 'style-editor')
  .addEdge('refinement', 'accuracy-editor')
  .addEdge('refinement', 'readability-editor')
  .addEdge('refinement', 'style-editor')
  .addEdge(['accuracy-editor', 'readability-editor', 'style-editor'], 'lead-editor')
  .addConditionalEdges(
    'lead-editor',
    (state) => {
      if (state.finalStatus === 'Final Edits Required' && state.editorFeedback?.length) {
        return 'REFINE'
      }
      return 'END'
    },
    {
      REFINE: 'refinement',
      END: '__end__'
    }
  )

export const graph = builder.compile()

graph.name = 'Translate Workflow'
